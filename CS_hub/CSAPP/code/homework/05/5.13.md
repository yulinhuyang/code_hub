# 5.13

## A

我认为 %xmm1 是局部变量，所以没有放入下数据流图中。

```text
%bx %rax %rbp %xmm0 %rcx
 |    |    |     |    |
 |    |    |     |    +--> +------+
 |    |    |     |    |    | load |-----+     vmovad 0(%rbp,%rcx,8),%xmm1
 |    |    +-----|----|--> +------+     |
 |    |    |     |    +--> +------+     |  -+
 |    |    |     |    |    | load |---+ |   |
 |    +----|-----|----|--> +------+   | |   |
 |    |    |     |    |    +------+ <-+ |   +- vmulsd (%rax,%rcx,8),%xmm1,%xmm0
 |    |    |     |    |    | mul  |     |   |
 |    |    |     |    |    +------+ <---+  -+
 |    |    |     |    |       ↓
 |    |    |     +----|--> +------+
 |    |    |          |    | add  |           vaddsd %xmm1,%xmm0,%xmm0
 |    |    |     +----|--< +------+
 |    |    |     |    +--> +------+
 |    |    |     |         | add  |           addq $1, %rcx
 |    |    |     |    +--< +------+
 |    |    |     |    |       ↓
 |    |    |     |    |    +------+
 +----|----|-----|----|--> | cmp  |           cmpq %rbx, %rcx
 |    |    |     |    |    +------+
 |    |    |     |    |       ↓
 |    |    |     |    |    +------+
 |    |    |     |    |    | jne  |           jne .L15
 |    |    |     |    |    +------+
 v    v    v     v    v
%bx %rax %rbp %xmm0 %rcx

```

以下是仿照图 5-14 绘制的抽象数据流图，

1. 只有在循环中改变数值的寄存器，才会存在于下图中。
1. 由于图中的 [load] 和 [mul] 不会改变下图中寄存器中的值，所以没有放置在竖线当中。
1. 由于浮点的加法更耗时，所以，右侧的竖线，成为关键路径。

```text
%rcx                   %xmm0
  |                      |  <-- key path
  +-->[load]-----+       |
  |              |       |
  |              v       v
  +-->[load]-->[mul]-->[add]
  |                      |
  |                      |
  v                      |
[add]                    |
  |                      |
  v                      v
%rcx                   %xmm0
```

## B

根据 361 页， 5.7.2 中的图 5-12 所示， 浮点加法的延迟是 3 个周期，所以 CPE 的下界是 3。

## C

根据 361 页， 5.7.2 中的图 5-12 所示， 浮点加法的延迟是 1 个周期，所以 CPE 的下界是 1。

## D

简单地说，是因为 [mul] 不在上图的关键路径上。所以，计算的 CPE 由关键路径上最耗时的浮点 [add] 的延迟周期决定。

```text
%rcx (0)               %xmm0  <0>
  |                      |  <-- key path
  +-->[load]-----+       |
  |              |       |
  |              v       v
  +-->[load]-->[mul]-->[add]
  |                      |
  v                      |
[add]                    |
  |                      |
  v                      v
%rcx (1)               %xmm0  <1>
  ↓                      ↓
[add]                  [add]
  ↓                      ↓
%rcx (2)               %xmm0  <2>
  ↓                      ↓
[add]                  [add]
  ↓                      ↓
%rcx (3)               %xmm0  <3>
  ↓                      ↓
[add]                  [add]
  ↓                      ↓
%rcx (4)               %xmm0  <4>
  ↓                      ↓
[add]                  [add]
  ↓                      ↓
%rcx (5)               %xmm0  <5>
```

以下是我的猜想。

假设循环进行了 6 次，由于左边的路径上的 [add] 的延迟和发射都只需要 1 个周期，很有可能到第 8 个周期的时候，左边的路径就已经走到头了。而此时，右边的周期还只运行到第 2 次循环。所以，两边的路径不是同时结束的。

另外，左边路径一旦 [add] 完成后，得到了 %rax 的新值，立马就可以 [load] 加 [mul] 了。再加上，处理器有两个乘法处理单元，可以进行指令级的并行计算。相当于每过 2.5 个周期就可以完成一个 [mul] 运算，这就比不得不依次完成的浮点 [add] 快了。

综上，for 循环开始后不久，当需要进行浮点 [add] 的时候， [mul] 的结果早就准备好等着啦。所以，CPE 取决于浮点 [add] 的周期数。